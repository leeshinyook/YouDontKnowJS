# 콜백

> 어떤 경우든 함수는 `콜백(Callback)` 역할을 한다. 
>
> 큐에서 대기 중인 코드가 처리되자마자 본 프로그램으로 돌아올 목적지이기 때문이다.

> 프라미스를 알기전에 무엇을, 왜 추상화하는지 모르고선 그 결과물을 효과적으로 활용할 수 없다!

- 비결정적 시간 동안 중지되고, 이전 위치로 다시 돌아와서 나머지 후반부 프로그램이 이어진다.
- 연속성을 감싼 캡슐화한 장치이다.



### 사람의 두뇌

> 인간은 스스로 멀티태스커라고 말하지만, 그 사건들을 잘게 쪼개어 보면,
>
> 아주 재빠른 콘텍스트 교환기처럼 행동하는 것 이다.





### 콜백지옥

```javascript
doA( function() {
  doB();
  
  doC( function() {
    doD();
  })
  
  doE();
});
doF();

// A F B C E D 순으로 실행된다.
```

> 위같은 문제를 해결하고자, 개발자들은 수많은 하드 코딩을 하는데, 이러한 경우의 수를 죄다 나열하는건
>
> 코드가 복잡해 질 뿐만이 아니라, 관리 및 수정이 아주 힘들어진다.
>
> 이를 `Callback Hell` 이라고 한다.

- 콜백 호출 시 오류가 날 만한 경우의 수
  - 콜백을 너무 일찍 부른다.
  - 콜백을 너무 늦게 부른다.
  - 콜백을 너무 적게 또는 너무 많이 부른다.
  - 필요한 환경/인자를 정상적으로 콜백에 전달치 못한다.
  - 일어날지 모를 에러 / 예외를 무시한다.

> 즉, 제어의 역전(`Inversion Of Contro`) 상황이 발생한다.
>
> 작성한 프로그램의 제어권(실행 흐름)이 개발자에게 있는것이 아닌, 프로그램에 넘어가버림.



### 콜백을 구하라

1. 분할 콜백 => ES6 프라미스

2. 에러 우선 스타일

   ~~~javascript
   function response(err, data) {
     if(err) console.error(err); // err를 우선적으로 잡는다.
     else console.log(data);
   }
   
   ajax("http://someurl.com", response);
   ~~~

3. 반복적인 관용코드(인자를 이용한 방어코드, 타입가드 등..)

> 이렇게 콜백을 처리하다보면, 비대해진 관용코드가 전체 프로젝트를 짓누르는 현상이 발생한다.
>
> 콜백은 고생할 각오가 필요하다.. 코드 추론에 투자해야할 노력이 매우 크다.



### 정리

> 위 같은 콜백의 어려움을 해결하기 위해 ES6부터 굉장한 해결책이 등장한다.
>
> 무턱대고 사용하는 것보다 그 흐름을 알고, 무엇을 추상화하는지 아는것이 중요하다!!!

- 비동기 프로그래밍 환경에서 콜백만으로 충분치 않다.
- 콜백을 사용하면 제어의 역전이 일어나서 믿음성(되겠지?) 문제에 봉착하게 된다.
  - 위 문제를 해결하고자 들어가는 개발자의 코드는 유지보수가 어려운 코드로 변질된다.
- 위 문제를 해결하고자 더 정교하고, 믿음직스러운 비동기 패턴이 ES6에 등장한다.
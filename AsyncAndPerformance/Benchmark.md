# 벤치마킹과 튜닝



### 벤치마킹의 오해

> 우리는 보통 어떻게 성능평가를 하나?

~~~javascript
var start = (new Date()).getTime();
// 측정하고자 하는 작업
var end = (new Date()).getTime();
console.log("소요시간 :",(end - start));
~~~

> 나도 역시 위의 방법을 떠올렸다.
>
> 저자는 위의 방법이 완전히 틀렸다고 전한다.

- 테스트환경이 지나치게 낙관적이다.
  - 독립적 테스트는 자바스크립트엔진이 최적화를 이루어내기 좋지만, 실제 프로그램은 최적화 정도가 떨어질 수 있다.
- 작업 속도가 늘 그 속도로 돌아가리란 보장이 없다.
  - 엔진또는 시스템이 어떠한 간섭을 일으킬지 아무도 예상할 수 없다.

### 반복

> 그렇다면, 위 방법에서 수많은 반복을 실행하여 통계를 내면 안되나?

예를들어, 100번 실행하고 총 133밀리초가 나왔다. 그러면 1번 실행시간은 1.33밀리초인가?

> 틀렸다. 반복 테스트를 한다고 하더라도 몇가지의 `이상점(다른 측정치보다 지나치게 동떨어진 값)` 이 생길 확률이 있다. 
>
> 이러한 이상점이 2개만 있어도, 평균치에는 상당한 타격을 준다.
>
> 그래서, 위의 방법은 정말 많은 샘플데이터가 필요하다.



### Benchmark.js

> 벤치마킹 도구를 제공한다.
>
> 전문적인 벤치마킹의 마스터들이 만들어낸 통계적으로 신뢰성이 확보된 툴.
>
> 성능 평가를 위한다면 위 벤치마킹도구를 사용하라



### jsPerf.com

> 신뢰할 수 있는 결론을 원한다. 자바스크립트는 브라우저, 모바일 디바이스등 다양한 환경에서 돌아가니
>
> 이 들의 통계치를 얻고 싶다면 위 사이트를 참고하자.



## 미시성능

> a++, ++a 뭐가 빠를까?

- a++이 더 빠르다. 하지만 이러한 고민은 자바스크립트에서 시간 낭비다.
  - 왜? 자바스크립트 엔진이 나보다 똑똑해.

~~~javascript
function factorial(n) {
  if(n < 2) return 1;
  return n * factorial(n - 1);
}

factorial(5); // 120
~~~

> 유명한 팩토리얼 재귀함수 호출이다.
>
> 자바스크립트 엔진이 있는 그대로 이를 해석해서 실행시킬까? 아니다.
>
> 어떠한 엔진은 소스 코드의 재귀가 루프 하나로 더 쉽게 표현된다면`풀림재귀(Unrolling Recursion)` 를 한다.

~~~javascript
function factorial(n) {
  if(n < 2) return 1;
  
  var res = 1;
  for(var i = n; i > 1; i--) {
    res *= i;
  }
  return res;
}
factorial(5); // 120
~~~

- 재귀코드를 위처럼 풀어버린다.

> 넓은 시야에서 보자면, 자바스크립트 엔진이 언제라도 이처럼 풀림 재귀를 단행 할 수 있다. 즉, 개발자가 코딩한대로 
>
> 소스코드를 실행하지 않을 수 있다.
>
> 개발자는 단지 논리에 맞게 코드를 작성하면 된다.

- 성능 최적화에 관해서라면 나는 자바스크립트 엔진을 능가할 수 없다.



## 똑같은 엔진은 없다.

> 노드JS는 V8 자바스크립트엔진을 이용한다. 그러나 훗날, 언제나 v8엔진이 사용되리라하는 확신은 어디에도 없다.
>
> 현재는 웹 기능을 더욱 더 최적화하기 위해서 브라우저 간 무한 경쟁을 펼치고 있다.
>
> 미래에는 어떻게 될까?

- 개발자는 일단 올바르고 논리적인 코드를 작성하고, 나중에 브라우저 업데이트 시 성능 개선이 이루어지길 기대하라



## 꼬리 호출 최적화(TCO)

> ES6부터 꼬리 호출은 함수 호출부가 다른 함수의 '꼬리'부분에 있고 호출이 끝나면 더 이상 수행할 작업을 남기지 않는 방식

~~~javascript
function foo(x) {
  return x;
}
function bar(y) {
  return foo(y + 1); // 꼬리 호출
}
function baz() {
	return 1 + bar(45); // 꼬리 호출 아님
}
~~~

> 원래는 새 함수를 호출하려면 스택프레임이라는 호출 스택을 쌓기 위해 별도의 메모리 할당이 필요하다.
>
> 즉, foo() bar() baz()를 한번 호출시 스택 프레임이 소모된다.

- 꼬리 호출 최적화
  - bar()가 끝난뒤, foo()를 호출할 때 새로운 스택 프레임을 생성치 않고, 기존 bar()의 스택 프레임을 사용한다.

> TCO를 이용하면, 실행할 다른 함수의 꼬리 부분에서 리소스를 추가하지 않고도 함수를 호출할 수 있다.
























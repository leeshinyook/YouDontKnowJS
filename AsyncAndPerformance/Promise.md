# 프라미스

> 콜백은 제어의 역전이라고 했다.
>
> 프라미스는 제어의 재역전이다!
>
> 개발자가 그 제어권을 꽉 잡고있는 체계



### 프라미스

- 프라미스는 항상 이룸(`Fullfillment`) 와 버림(`Rejection`) 으로 귀결된다.
- 프라미스는 일단 귀결되면, 상태가 그대로 유지된다. 즉, 불변성을 가진다.



### 프라미스의 이벤트

> then()을 통한 'then' 이벤트구독기의 등록이며, 더 정확하게 말하면
>
> '이룸' 혹은 '버림' 이벤트를 등록하는 것이다.



## 프라미스의 믿음

> 프라미스 특성은 콜백의 한계점에 해결책을 제시하게끔 설계되었다.

- 너무 빨리 호출

  - then()을 호출하면 프라미스가 이미 귀결된 이후라 해도 then에게 건넨 콜백은 항상 비동기적으로만 부른다.
  - 프라미스는 자르고를 알아서 예방한다.

- 너무 늦게 호출

  - 프라미스가 귀결되면 then()에 등록된 콜백들이 그 다음 비동기 기회가 찾아왔을 때 순서대로 실행된다.

- 한번도 콜백을 안 호출

  - 프라미스가 스스로 귀결 사실을 알리지 못하게 막을 방도는 없다.

- 너무 가끔, 너무 종종 호출

  - 프라미스는 정의상 단 한번만 귀결된다.

- 인자 / 환경 전달 실패

  - 프라미스 귀결 값은 (이룸 / 버림) 딱 하나 뿐이다.

- 에러 / 예외 삼키기

  - 귀결을 기다리는중 언제라도 에러가 발생하면 프라미스를 강제로 버린다.

  ```Javascript
  var p = new Promise( function(resolve, reject) {
    foo.bar(); // 'foo'는 정의된 바 없으므로 에러발생
    resolve(42); // 실행되지 않는다.
  });
  p.then(function fulfilled() {
    // 실행되지 않는다.
  },function rejected(err) {
    // 'foo.bar()'에서 에러가 나므로 
    // err는 TypeError 예외 객체일 것 이다.
  })
  ```



## 연쇄 흐름

- 프라미스에 then()을 부를 때마다 생성하여 반환하는 새 프라미스를 계속 연쇄할 수 있다.
- then()의 이룸 콜백 함수가 반환한 값은 어떤 값이든 자동으로 연쇄된 프라미스의 이룸으로 셋팅된다.

~~~javascript
var p = Promise.resolve(21);

var p2 = p.then(function(v) {
  console.log(v); // 21
  
  // 'p2'는 이룸 
  return v * 2;
})

// p2를 연쇄한다.
p2.then(function(v) {
  console.log(v); // 42
})
~~~

> 프라미스 시퀀스가 각 단계마다 비동기적으로 작동하게 만드는 핵심은 Promise.resolve()에 넘긴 값이 어떤 최종값이
>
> 아닌, 프라미스/데너블일 때!
>
> 프라미스를 받는다 = 도로 뱉어내라
>
> 데너블 = 일단 한번 풀어보고 아니면 원하는 값이 나올 때까지 재귀적으로 계속 풀어본다.



## 에러처리

- 분산 - 콜백  `Split-Callback` 스타일로 이룸/버림 각각의 콜백을 지정하여 에러 처리를 한다.

~~~javascript
var p = Promise.reject("허걱");

p.then(
	function fulfilled() {
	//	 실행되지 않는다.
  },
  function rejected(err) {
    console.log(err); // 허걱
  }
)
~~~



### 잡히지 않는 에러

~~~javascript
var p = Promise.resolve(42);

p.then(function fulfilled(msg) {
  // 숫자에 문자열 함수가 없으니 에러가 날 것이다.
  console.log(msg.toLowerCase());
}).catch(hanleErrors);
~~~

> 프라미스 에러처리는 `절망의 구덩이 ` 방식으로 설계되어 있다.
>
> 에러가 나도 프라미스 상태에 따라 무시할 수 있다고 보기 때문, 상태 감지를 하지 않는다면
>
> 에러는 생을 마감한다. 

- 만약 handleErrors() 함수에서 에러가 난다면?
  - 무작정 catch하나를 더 붙일 순 없다. 이 함수역시 실패할 가능성이 있기 때문이다.



### 성공의 구덩이

> 기본적으로 프라미스는 그다음 잡/이벤트 루프 틱 시점에 에러 처리기가 등록되어 있지 않을 경우 버림을 알리도록 설계됨.
>
> 감지되기 전까지 버림 프라미스의 버림 상태로 계속해서 유지하려면 defer()를 호출해서
>
> 해당 프라미스에 관한 자동에러 알림 기능을 끈다.

- 자동에러 알림을 기능을 끈다?
  - 개발자가 이 에러 처리를 '나중'에 할테니 미루겠다는 의사를 밝혀야한다. 
  - 결국, 에러는 잡아야한다



## 프라미스 패턴

### Promise.all([ ])

> 2개 이상의 비동기 처리가 동시에 움직인다.
>
> 복수의 병렬/동시 작업이 끝날 때 까지 진행하지 않고 대기하는 관문이다.

~~~javascript
var p1 = request("http://some.url.1/");
var p2 = request("http://some.url.2/");

Promise.all([p1, p2])
.then(function(msgs) {
  // p1, p2의 둘다 이루어져 여기에 메시지가 전달된다.
  	return request("http://some.url.3/v=" + msgs.join(','))
})
.then(function(msg){
  console.log(msg);
})
~~~



### Promise.race([ ])

> 최초로의 프라미스만 인정하고 나머지는 무시한다.
>
> 프라미스에서는 경합이라고 한다.

~~~javascript
var p1 = request("http://some.url.1/");
var p2 = request("http://some.url.2/");

Promise.race([p1, p2])
.then(function(msg) {
  // p1, p2의 둘 중 하나만 경합의 승리자가 되어 넘어온다.
  	return request("http://some.url.3/v=" + msg)
})
.then(function(msg){
  console.log(msg);
})
~~~





## 프라미스의 한계



### 시퀀스 에러 처리

> 에러 처리기가 없는 프라미스 연쇄에서 에러가 나면 나중에 어딘가에서 감지될 때 까지
>
> 연쇄를 따라 하위로 전파한다.

- 각 단계에서 에러를 처리할 방법이 없다.
- Catch를 통해 에러처리를 해도 안에서 또 에러가 발생할 경우 감지할 방법이 없다.



### 프라미스는 취소 불가

> 일단 프라미스를 생성하여 이룸/버림 처리기를 등록하면 외부에서 프라미스 진행을 멈출 방법이 없다.



### 프라미스의 성능

- 콜백보다 프라미스가 처리량이 많고, 속도가 더 느리다. 
  - 하지만, 콜백지옥을 견딜자신없다 -> 프라미스를 쓰자!
- 프라미스의 믿음성, 예측성, 조합성과 같은 장점을 본다면 성능보다는 이러한 것이 가져다 주는 이득이 더 큰 것 같다.












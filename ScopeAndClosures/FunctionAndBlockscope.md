# 함수 vs 블록 스코프

> 스코프는 컨테이너 또는 바구니 구실을 하는 일련의 버블이고, 변수나 함수 같은 확인자가 그 안에서 선언된다.  
> 이 버블은 경계가 분명히 중첩되고, 그 경계는 프로그래머가 코드를 작성할 때 결정된다.

## 함수 기반 스코프

> 함수 스코프는 모든 변수가 함수에 속하고 함수전체(심지어 중첩된 스코프에서도에 걸쳐  
> 사용되며 재사용된다는 개념확고하게 한다.

## 일반 스코프에 숨기

- 함수를 선언하고 그 안에 코드를 넣는다. 바꿔 생각해보는 것도 좋다.
- 작성한 코드에서 임의 부분을 함수 선언문으로 감싼다. 이는 해당코드를 '숨기는' 효과를 낸다.

  - 새로운 스코프 버블이 생성
  - 소프트웨어 디자인원칙 최소권한의 원칙(최소권위 or 최소노출)과 관련되어있다.
  - 접근할 수 있도록 내버려 두는 것은 불필요할 뿐 아니라 위험하다.
  - 충돌회피 : 글로벌 네임스페이스 & 모듈관리

## 스코프 역할을 하는 함수

```javascript
var a = 2;

function foo() {
  var a = 3;
  console.log(a); //3
}
foo();
console.log(a); //2
```

    foo()라는 확인자 이름으로 둘러싸인 스코프를 오염시킨다.

- 익명함수

  - 스택 추척 시 표시할 이름이 없어서 디버깅이 어렵다.
  - 이름없이 재귀호출을 하려면 폐기예정인, arguments.callee참조가 필요하다.
  - 이름은 쉽게 이해하고 읽을 수 있는 코드 작성에 도움을 주는데, 이것을 생략한다.

    따라서, 함수표현식을 사용할 때 이름을 항상 사용하는 것이 좋다.

```javascript
setTimeout(function timeoutHandler() {
  console.log("I waited 1 second");
}, 1000);
```

## 함수 표현식 즉시 호출하기

```javascript
var a = 2;

(function IIFE() {
  var a = 3;
  console.log(a); //3
})();

console.log(a); //2
```

    이를 보통 즉시실행함수라고 부른다.

```javascript
var a = 2;

(function IIFE(def) {
  def(window);
})(function def(global) {
  var a = 3;
  console.log(a); // 3;
  console.log(global.a); // 2;
});
```

    위 패턴은 UMD(범용 모듈정의)프로젝트에서 사용한다.

## 스코프 역할을 하는 블록

- with
  - with문 안에서 생성된 객체는 바깥 스코프에 영향 주는 일 없이 with문이 끝날때 까지만 존재한다.
- try ~ catch
  - catch 부분에서 선언된 변수는 catch블록 스코프에 속한다.
  - catch 문이 둘 이상이 있을 경우 경고를 보낸다.(그 변수들은 안전하게 각기 다른 블록 스코프에 속하기 때문이다.)
- let
  - let은 선언한 변수를 위해 해당 블록 스코프를 이용한다.
  - let을 사용한 선언문은 속하는 스코프에 호이스팅효과를 받지 않는다.
  - let으로 선언된 변수는 실제 선언문 전에는 명백하게 존재하지 않는다.
- 가비지 콜렉션(Garbage Collection)
  - 블록 스코프를 적절하게 이용하면 메모리회수에 도움을 준다.

## 블록스코프 변수 (let, const)

> 더 읽기 쉽고 유지보수가 쉬운 코드를 작성하기 위해 두 기술을 적절한 곳에 사용하면 베스트!
